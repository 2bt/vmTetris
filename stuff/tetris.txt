# vim: tabstop=8 shiftwidth=8 noexpandtab syntax=python

# TODO: increase speed only for every 10 cleared lines

	# memory addresses
	define	PREGRID		22
	define	GRID		44

	define	STARTPOS	26

	# colors
	define	COLOR_FRAME	7
	define	COLOR_STONE	4
	define	COLOR_FILL	5

	# registers
	define	A		r0
	define	B		r1
	define	C		r2
	define	D		r3
	define	S		r4
	define	T		r5
	define	X		r6
	define	POS		r7
	define	POS2		r8
	define	ROT		r9
	define	ROT2		r10
	define	STONE		r11
	define	SPEED		r12
	define	DELAY		r13
	define	DOWN		r14


	inc	DELAY
	mov	SPEED	30


	# load stone data
	mov	X	360


	# square
	mov	[X]	13
	mov	[X]	10
	inc	[X]

	mov	[X]	13
	mov	[X]	10
	inc	[X]

	mov	[X]	13
	mov	[X]	10
	inc	[X]

	mov	[X]	13
	mov	[X]	10
	inc	[X]


	# T
	mov	[X]	11
	mov	[X]	2
	mov	[X]	10

	inc	[X]
	mov	[X]	10
	mov	[X]	12

	inc	[X]
	mov	[X]	10
	mov	[X]	2

	inc	[X]
	mov	[X]	12
	mov	[X]	10

	# I
	mov	[X]	1
	mov	[X]	22
	mov	[X]	11

	mov	[X]	11
	mov	[X]	2
	inc	[X]

	mov	[X]	1
	mov	[X]	22
	mov	[X]	11

	mov	[X]	11
	mov	[X]	2
	inc	[X]

	# L
	inc	[X]
	mov	[X]	22
	inc	[X]

	mov	[X]	11
	mov	[X]	2
	mov	[X]	9

	inc	X
	inc	[X]
	mov	[X]	22

	mov	[X]	2
	mov	[X]	9
	mov	[X]	2

	# J
	inc	[X]
	mov	[X]	21
	inc	[X]

	inc	X
	mov	[X]	11
	mov	[X]	2

	inc	[X]
	inc	[X]
	mov	[X]	21

	mov	[X]	11
	mov	[X]	2
	mov	[X]	11

	# Z
	inc	X
	inc	[X]
	mov	[X]	12

	mov	[X]	2
	mov	[X]	11
	mov	[X]	10

	inc	X
	inc	[X]
	mov	[X]	12

	mov	[X]	2
	mov	[X]	11
	mov	[X]	10

	# S
	inc	[X]
	inc	[X]
	mov	[X]	9

	inc	[X]
	mov	[X]	12
	mov	[X]	11

	inc	[X]
	inc	[X]
	mov	[X]	9

	inc	[X]
	mov	[X]	12
	mov	[X]	11



	# prepare grid
	mov	X	PREGRID
	mov	T	22
prep1:
	mov	[X]	COLOR_FRAME
	mov	C	10
	add	X	C
	dec	T
	jnz	prep1

	mov	T	12
prep2:
	mov	[X]	COLOR_FRAME
	dec	T
	jnz	prep2





	# clear screen
	mov	C	27
	put
	mov	C	91
	put
	mov	C	50
	put
	mov	C	74
	put

	# hide cursor
	mov	C	27
	put
	mov	C	91
	put
	mov	C	63
	put
	mov	C	50
	put
	mov	C	53
	put
	mov	C	108
	put


	jmp	start

mainloop:


	# save position and rotation
	mov	POS2	POS
	mov	ROT2	ROT
	mov	DOWN	0
	# auto drop
	dec	DELAY
	jz	down


	# input
read:
	mov	A	T
	get	T
	inc	T
	jnz	read



	# quit
	mov	C	28
	sub	A	C
	jz	gameover
	mov	C	86
	sub	A	C
	jz	gameover



		# move
		mov	C	47
		add	A	C
		jnz	nodown
	down:
		mov	C	11
		add	POS	C
		# remember that we're moving down
		inc	DOWN
		# reset delay
		mov	DELAY	SPEED
	nodown:
		dec	A
		jnz	noleft
		inc	POS
	noleft:
		dec	A
		jnz	noright
		dec	POS
	noright:

		# rotate
		mov	C	52
		sub	A	C
		jnz	norot
		mov	D	9
		sub	ROT	D
		jz	norot
		mov	D	12
		add	ROT	D
	norot:



	# update grid
	mov	B	COLOR_STONE

updategrid:

		mov	X	PREGRID
		mov	T	23
	update1:
		mov	S	12

	update2:
		mov	A	[X]


		# clear old entries
		mov	C	COLOR_STONE
		sub	C	A
		jnz	update3
		mov	A	0
		mov	[X]	A
		dec	X
	update3:

		# check if the 4 stone cells occupy the current cell
		mov	C	POS
		mov	D	12
		add	C	D
		sub	C	X
		jz	occupy

		mov	D	STONE
		add	D	ROT

		mov	C	POS

		add	C	[D]
		sub	C	X
		jz	occupy
		add	C	X
		inc	D
		add	C	[D]
		sub	C	X
		jz	occupy
		add	C	X
		inc	D
		add	C	[D]
		sub	C	X
		jnz	nooccupy

	occupy:
		mov	A	A
		jz	nocollision


			# break endless loop
			# check if stone is at spawn position
			mov	C	STARTPOS
			sub	C	POS
			jnz	nospawn
			mov	C	ROT
			sub	C	ROT2
			jz	gameover
		nospawn:


			# enable cell write only when moving downward
			mov	DOWN	DOWN
			jz	nowrite
			mov	B	COLOR_FILL

		nowrite:

			# reset position and rotation
			mov	POS	POS2
			mov	ROT	ROT2

			jmp	updategrid


	nocollision:
		# write cell
		mov	[X]	B
		dec	X

	nooccupy:
		inc	X

		dec	S
		jnz	update2

		dec	X

		dec	T
		jnz	update1
	# end update grid



	# check if stone was dropped
	mov	C	COLOR_FILL
	sub	B	C
	jnz	nodrop


start:

	# reset position on collision
	mov	POS	STARTPOS

	# select new random stone
	mov	STONE	7
	rnd
	mov	C	30
	add	STONE	C
	mov	C	12
	mul	STONE	C
	# random rotation
	mov	ROT	3
	rnd
	mov	C	3
	mul	ROT	C


	# check for gameover
check_gameover:
	mov	X	PREGRID
	mov	T	X
	mov	C	COLOR_FILL
check1:
	mov	A	[X]
	inc	X
	sub	A	C
	jz	gameover
	dec	T
	jnz	check1




	# check for full lines
	mov	X	GRID
	mov	T	21
	full1:
		inc	X
		mov	S	10
		mov	A	10

		full2:
			mov	C	COLOR_FILL
			sub	C	[X]
			jnz	full3
			dec	A
		full3:
			inc	X
			dec	S
			jnz	full2

		mov	A	A
		jnz	full4

		# line is full
		# increase line count
		mov	S	0
		digit1:
			inc	[S]
			dec	S
			mov	C	10
			sub	C	[S]
			jnz	digit2
			mov	[S]	0
			jmp	digit1
		digit2:


		# increae speed
		dec	SPEED


		# shift all upper lines down
		mov	S	X
		mov	A	X
		mov	C	11
		sub	A	C
		shift:
			mov	[S]	[A]
			dec	S
			dec	S
			dec	A
			mov	B	A
			mov	C	22
			sub	B	C
			jnz	shift

	full4:
		dec	T
		jnz	full1



nodrop:

	# move cursor to corner
	mov	B	27
	put
	mov	C	91
	put
	mov	C	49
	put
	mov	C	59
	put
	mov	C	72
	put


	# draw grid
	mov	X	GRID
	mov	T	21
draw1:
	mov	S	12
draw2:
	# pixel
	mov	B	B
	put
	mov	C	91
	put
	mov	C	52
	put

	mov	A	[X]
	mov	D	48
	add	A	D
	put

	mov	C	109
	put
	mov	C	32
	put
	put


	# next cell
	inc	X
	dec	S
	jnz	draw2


	# next row
	dec	X
	mov	C	10
	put

	dec	T
	jnz	draw1


	# sleep and loop
	slp
	jmp	mainloop

gameover:


	# reset color
	mov	A	27
	put
	mov	B	91
	put
	mov	D	48
	put
	mov	C	109
	put

	# show cursor
	mov	A	A
	put
	mov	B	B
	put
	mov	C	63
	put
	mov	C	50
	put
	mov	C	53
	put
	mov	C	104
	put

	# print number of cleared lines
	mov	C	76	# L
	put
	mov	C	105	# i
	put
	mov	C	110	# n
	put
	mov	C	101	# e
	put
	mov	C	115	# s
	put
	mov	C	58	# :
	put
	mov	C	32
	put


	# print digits
	mov	X	4
skip_zero:
	mov	C	[X]
	jnz	skip_done
	dec	X
	jnz	skip_zero
skip_done:
	inc	X
next_digit:
	dec	X
	add	[X]	D
	put
	dec	X
	jnz	next_digit
	mov	C	10
	put
