# vim: tabstop=8 shiftwidth=8 noexpandtab syntax=python



	# memory addresses
	define	POS_	0

	define	ROT_	1
	define	ROT2_	2

	define	STONE_	4


	define	DOWN_	3
	define	LINES_	5


	define	PREGRID_ 22
	define	GRID_	44
	define	START	27


	# colors
	define	FRAME	7
	define	STONE	4
	define	FILL	5



	define	A	r0
	define	B	r1
	define	C	r2
	define	D	r3
	define	S	r4
	define	T	r5
	define	X	r6
	define	POS	r7


	# set cursor position
	mov	POS	START


	# prepare grid
	mov	X	PREGRID_
	mov	T	22


prep1:
	mov	[X]	FRAME
	mov	C	11
	add	X	C
	dec	T
	jnz	prep1

	mov	T	12
prep2:
	mov	[X]	FRAME
	inc	X
	dec	T
	jnz	prep2



	# load stone data
		mov	X	32
		mov	C	10
		mul	X	C


		# square
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X

		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X

		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X

		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X


		# T
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X

		inc	[X]
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X

		inc	[X]
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X

		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X

		# I
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		mov	[X]	11
		inc	X
		mov	[X]	11
		inc	X

		mov	[X]	10
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X

		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		mov	[X]	11
		inc	X
		mov	[X]	11
		inc	X

		mov	[X]	10
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X

		# L
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X

		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X
		mov	[X]	9
		inc	X

		inc	X
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		mov	[X]	11
		inc	X

		mov	[X]	2
		inc	X
		mov	[X]	9
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X

		# J
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X

		inc	X
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X

		inc	[X]
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X
		mov	[X]	11
		inc	X

		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X

		# Z
		inc	X
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X

		mov	[X]	2
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X

		inc	X
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X

		mov	[X]	2
		inc	X
		mov	[X]	10
		inc	X
		inc	[X]
		inc	X
		mov	[X]	10
		inc	X

		# S
		inc	[X]
		inc	X
		inc	[X]
		inc	X
		mov	[X]	9
		inc	X
		inc	[X]
		inc	X

		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		mov	[X]	11
		inc	X

		inc	[X]
		inc	X
		inc	[X]
		inc	X
		mov	[X]	9
		inc	X
		inc	[X]
		inc	X

		inc	[X]
		inc	X
		mov	[X]	11
		inc	X
		inc	[X]
		inc	X
		mov	[X]	11



	# clear screen
	mov	C	27
	put
	mov	C	91
	put
	mov	C	50
	put
	mov	C	74
	put


	jmp	start

mainloop:


	# save cursor position and rotation
	mov	C	POS_
	mov	[C]	POS

	mov	C	ROT_
	mov	D	ROT2_
	mov	[D]	[C]



	# clear down flag
	mov	C	DOWN_
	mov	[C]	0



	# input
read:
	mov	A	T
	get	T
	inc	T
	jnz	read



	# quit
	mov	C	28
	sub	A	C
	jz	done
	mov	C	86
	sub	A	C
	jz	done



		# move
		mov	C	47
		add	A	C
		jnz	nodown
		mov	C	11
		add	POS	C
		# remember that we're moving down
		mov	C	DOWN_
		inc	[C]
	nodown:
		dec	A
		jnz	noleft
		inc	POS
	noleft:
		dec	A
		jnz	noright
		dec	POS
	noright:

		# rotate
		mov	C	52
		sub	A	C
		jnz	norot
		mov	C	ROT_
		mov	D	12
		sub	[C]	D
		jz	norot
		mov	D	16
		add	[C]	D
	norot:



	# update grid:
	mov	B	STONE
	updategrid:
		mov	X	GRID_
		mov	T	4
	update1:
		mov	S	0

	update2:
		mov	A	[X]


		# clear old entries
		mov	C	STONE
		sub	C	A
		jnz	update3
		mov	A	0
		mov	[X]	A
	update3:



		# check if the 4 stone cells occupy the current cell
		mov	C	STONE_
		mov	D	[C]
		mov	C	ROT_
		add	D	[C]

		mov	C	POS

		add	C	[D]
		sub	C	X
		jz	occupy
		add	C	X
		inc	D
		add	C	[D]
		sub	C	X
		jz	occupy
		add	C	X
		inc	D
		add	C	[D]
		sub	C	X
		jz	occupy
		add	C	X
		inc	D
		add	C	[D]
		sub	C	X
		jnz	nooccupy


	occupy:

		mov	A	A
		jz	nocollision


			# enable cell write only when moving downward
			mov	C	DOWN_
			mov	C	[C]
			jz	nowrite
			mov	B	FILL
		nowrite:

			# reset cursor position and rotation
			mov	C	POS_
			mov	POS	[C]
			inc	C
			mov	D	C
			inc	D
			mov	[C]	[D]

			jmp	updategrid


	nocollision:
       		# write cell
       		mov	[X]	B
		# TODO: check for gameover

	nooccupy:


		inc	X

		inc	S
		mov	C	12
		sub	C	S
		jnz	update2

		dec	X

		inc	T
		mov	C	25
		sub	C	T
		jnz	update1
	# end update grid



	# check if stone was dropped
	mov	C	FILL
	sub	B	C
	jnz	nodrop


start:

	# reset cursor on collision
	mov	POS	START

	# select new random stone
	mov	D	7
	rnd
	mov	C	20
	add	D	C
	mov	C	16
	mul	D	C
	mov	C	STONE_
	mov	[C]	D
	# random rotation
	mov	D	3
	rnd




	# check for full lines
	mov	X	GRID_
	mov	T	4
	full1:
		inc	X
		mov	S	10
		mov	A	10

		full2:
			mov	C	FILL
			sub	C	[X]
			jnz	full3
			dec	A
		full3:
			inc	X
			dec	S
			jnz	full2

		mov	A	A
		jnz	full4

		# the line is full
		mov	C	LINES_
		inc	[C]

		# shift all upper lines down
		mov	S	X
		mov	A	X
		mov	C	11
		sub	A	C
		shift:
			mov	[S]	[A]
			dec	S
			dec	A
			mov	B	A
			mov	C	22
			sub	B	C
			jnz	shift

	full4:
		inc	T
		mov	C	25
		sub	C	T
		jnz	full1



nodrop:

	# move cursor to corner
	mov	C	27
	put
	mov	C	91
	put
	mov	C	49
	put
	mov	C	59
	put
	mov	C	72
	put


	# draw grid
	mov	X	GRID_
	mov	T	4
#	mov	X	11
#	mov	T	1
draw1:
	mov	S	0

draw2:

	# pixel
	mov	C	27
	put
	mov	C	91
	put
	mov	C	52
	put

	mov	A	[X]
	mov	C	48
	add	A	C
	put

	mov	C	109
	put
	mov	C	32
	put
	put


	# next cell
	inc	X
	inc	S
	mov	C	12
	sub	C	S
	jnz	draw2


	# next row
	dec	X
	mov	C	10
	put

	inc	T
	mov	C	25
	sub	C	T
	jnz	draw1


	# sleep and loop
	slp
	jmp	mainloop

done:


	# reset color
	mov	C	27
	put
	mov	C	91
	put
	mov	C	48
	put
	mov	C	109
	put

